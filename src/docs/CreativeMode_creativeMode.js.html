<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: CreativeMode/creativeMode.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: CreativeMode/creativeMode.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { useCallback, useState, useEffect } from "react";
import { useNodesState, useEdgesState, ReactFlowProvider } from "reactflow";
import "./creativeMode.css";
import { landingPageNodes } from "../../Flow/data/landingPage";
import { landingPageEdges } from "../../Flow/data/edges/landingPage";
import DefaultPackets from "../../Packet";
import AddDeviceButtons from "./addDeviceButtons";
import ServiceButtons from "./serviceButtons";
import SendPacketBox from "./sendPacketBox";
import CreativeModeFlow from "./creativeModeFlow";

/**
 * Represents the Creative Mode component.
 * @param {Object} props - The component props.
 * @param {Function} props.setOpenModal - A function to set the open modal state.
 * @param {Function} props.setIsCreativeMode - A function to set the creative mode state.
 * @returns {JSX.Element} - The rendered component.
 */

function CreativeMode({ setOpenModal, setIsCreativeMode }) {
  const [nodes, setNodes, onNodesChange] = useNodesState(landingPageNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(landingPageEdges);

  /**
   *A hook to update the client nodes every 10ms.
   */
  useEffect(() => {
    const intervalId = setInterval(() => {
      const clientInfoNodes = nodes.filter(
        (node) => node.className === "client-plugged"
      );
      const clientBuildNodes = nodes.filter(
        (node) => node.className === "client-build"
      );

      const tempClientNodes = clientInfoNodes.concat(clientBuildNodes);
      tempClientNodes.forEach((node) => {
        if (isNodeInRange(node.id, nodes)) {
          node.className = "client-plugged";
        } else {
          node.className = "client-build";
        }
      });

      // iterate through each node in tempClientNodes
      tempClientNodes.forEach((tempNode) => {
        // check if the node already exists in nodes
        const index = nodes.findIndex((node) => node.id === tempNode.id);
        if (index !== -1) {
          // remove the existing node from nodes
          nodes.splice(index, 1);
        }
        // add the new node to nodes
        nodes.push(tempNode);
      });
    }, 10);

    // Clear the interval when the component unmounts or when the nodes state changes
    return () => clearInterval(intervalId);
  }, [nodes]);

  /**
   * A callback function to add a node to the nodes state.
   * @param {string} device - The type of device to add.
   */
  const handleAddNode = useCallback(
    (device) => {
      const deviceNodes = nodes.filter((node) => node.className === device);
      const nodeCount = deviceNodes.length;
      const ipv4Address = generateIpv4Address();
      if (nodeCount >= 15) {
        setOpenModal(true, "vice uz jich nepridavej. Uz jich mas az moc");
      } else {
        const newNode = {
          id: `${ipv4Address}`,
          type: "default",
          position: { x: 300, y: 300 },
          className: `${device}`,
          data: { label: `${ipv4Address}` },
        };
        setNodes((prevNodes) => [...prevNodes, newNode]);
      }
    },
    [nodes, setNodes]
  );

  const [userPacketPath, setUserPacketPath] = useState([]);

  function handleSetUserPacketPath(path) {
    setUserPacketPath(path);
  }

  const userPacketData = [
    {
      id: "user-packet-7848975",
      path: userPacketPath,
      content: "01010101",
      from: "135.127.3.223",
      to: "29.52.143.155",
      speed: 10,
    },
  ];

  return (
    &lt;>
      {userPacketPath.length > 0 &amp;&amp; (
        &lt;DefaultPackets
          packetsData={userPacketData}
          repeat={0}
          marginleft={0}
          nodes={nodes}
        />
      )}
      &lt;SendPacketBox
        nodes={nodes}
        edges={edges}
        setOpenModal={setOpenModal}
        setPath={handleSetUserPacketPath}
      />
      &lt;ServiceButtons
        setIsCreativeMode={setIsCreativeMode}
        setOpenModal={setOpenModal}
      />
      &lt;AddDeviceButtons handleAddNode={handleAddNode} nodes={nodes} />

      &lt;ReactFlowProvider>
        &lt;CreativeModeFlow
          setEdges={setEdges}
          edges={edges}
          nodes={nodes}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
        />
      &lt;/ReactFlowProvider>
    &lt;/>
  );
}

/**
 * Determines if a node is in range of a wifi or bts node.
 * @public
 * @param {string} nodeId - The ID of the node to check.
 * @param {Object[]} nodes - An array of node objects.
 * @returns {boolean} - True if the node is in range, false otherwise.
 */
function isNodeInRange(nodeId, nodes) {
  const node = nodes.find((node) => node.id === nodeId);
  const wifiNodes = nodes.filter((node) => node.className === "wifi-build");
  const btsNodes = nodes.filter((node) => node.className === "bts-build");

  // Check if node is at most 100 away from some wifi nodes
  for (let i = 0; i &lt; wifiNodes.length; i++) {
    const wifiNode = wifiNodes[i];
    const distance = Math.sqrt(
      Math.pow(node.position.x - wifiNode.position.x, 2) +
        Math.pow(node.position.y - wifiNode.position.y, 2)
    );
    if (distance &lt;= 100) {
      return true;
    }
  }

  // Check if node is at most 200 away from some bts nodes
  for (let i = 0; i &lt; btsNodes.length; i++) {
    const btsNode = btsNodes[i];
    const distance = Math.sqrt(
      Math.pow(node.position.x - btsNode.position.x, 2) +
        Math.pow(node.position.y - btsNode.position.y, 2)
    );
    if (distance &lt;= 100) {
      return true;
    }
  }

  return false;
}

/**
 * Generates a random IPv4 address string.
 * @returns {string} - The generated IPv4 address.
 */
function generateIpv4Address() {
  let ipv4Address = "";
  for (let i = 0; i &lt; 4; i++) {
    ipv4Address += Math.floor(Math.random() * 256);
    if (i !== 3) {
      ipv4Address += ".";
    }
  }
  return ipv4Address;
}

export default CreativeMode;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#AddDeviceButtons">AddDeviceButtons</a></li><li><a href="global.html#CreativeMode">CreativeMode</a></li><li><a href="global.html#CreativeModeFlow">CreativeModeFlow</a></li><li><a href="global.html#Dialog">Dialog</a></li><li><a href="global.html#DropdownMenu">DropdownMenu</a></li><li><a href="global.html#EducationalMode">EducationalMode</a></li><li><a href="global.html#GoToEduModeDialog">GoToEduModeDialog</a></li><li><a href="global.html#NavItem">NavItem</a></li><li><a href="global.html#Navbar">Navbar</a></li><li><a href="global.html#Page">Page</a></li><li><a href="global.html#SendPacketBox">SendPacketBox</a></li><li><a href="global.html#ServiceButtons">ServiceButtons</a></li><li><a href="global.html#Sidebar">Sidebar</a></li><li><a href="global.html#countNodesByType">countNodesByType</a></li><li><a href="global.html#generateIpv4Address">generateIpv4Address</a></li><li><a href="global.html#isNodeInRange">isNodeInRange</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Thu Apr 06 2023 09:31:30 GMT+0200 (Středoevropský letní čas)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
